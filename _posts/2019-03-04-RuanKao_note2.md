---
title: 2.操作系统基本原理
categories:
- 笔记
tags:
- 软考笔记
---

# 2.操作系统基本原理

> 书写于190304

## 2.01 操作系统概述

![1551708818035](/assets/images/RuanKao_note/1551708818035.png)

![1551708831972](/assets/images/RuanKao_note/1551708831972.png)

## 2.02 进程管理

### 1. 进程状态

* **三态模型**

  运行态：所有资源都已经有了，而且在运行了

  就绪态：其他资源都就绪了，只差CPU状态

  等待态：差其他资源(如用户输入，外设接入)，并且还差CPU状态

![1551709059363](/assets/images/RuanKao_note/1551709059363.png)



* **五态模型**

  挂起操作：比如人为想把进程人为的挂起，那么就会产生静止就绪和静止阻塞

  ![1551709417090](/assets/images/RuanKao_note/1551709417090.png)

### 2. 前趋图

![1551709737039](/assets/images/RuanKao_note/1551709737039.png)

### 3. 进程的同步和互斥

互斥：在同一时刻，某个资源不允许多个进程占用该资源

同步：有速度差异需求的多个进程，有时需要速度快的停下来等待其他进程，例如下面的图，只有消费者消费完才允许生产者生产

![1551709998515](/assets/images/RuanKao_note/1551709998515.png)

单缓存区和多缓冲区：

![1551710094712](/assets/images/RuanKao_note/1551710094712.png)

### 4. PV操作

![1551710212311](/assets/images/RuanKao_note/1551710212311.png)

* **PV操作简单概述**

![1551710585558](/assets/images/RuanKao_note/1551710585558.png)

* **PV操作实例1**

![1551710696012](/assets/images/RuanKao_note/1551710696012.png)

* **PV操作实例2**

  ![1551711910060](/assets/images/RuanKao_note/1551711910060.png)

* **PV操作与前趋图**

  ![1551711975335](/assets/images/RuanKao_note/1551711975335.png)

### 4. 死锁问题

![1551795022531](/assets/images/RuanKao_note/1551795022531.png)

* **死锁的产生，预防和避免**

  ![1551795176723](/assets/images/RuanKao_note/1551795176723.png)

  * 死锁的产生
    * 互斥
    * 保持和等待：保持自己的资源，等待别人的资源
    * 不剥夺：系统不剥夺那些资源占用的进程
    * 环路等待：A等B，B等C，C等A
  * 死锁的避免
    * 有序资源分配法：资源先分给A，再分给B，再分给C

#### 银行家算法

* **例子**

  ![1551795598117](/assets/images/RuanKao_note/1551795598117.png)



## 2.03 存储管理

### 1. 分区存储组织

![1551796058096](/assets/images/RuanKao_note/1551796058096.png)

* 适应法
  * 首次适应法：从地址第小的开始，找到能插入的就插入
  * 最佳适应法：把剩余空间由小到大排成链表，从最小的开始走起
    * 内存碎片多
  * 最差适应算法：与最佳适应算法相反
  * 循环首次适应法：把剩余空间从地址最低开始，连成环链表，然后第一次分配空间的时候从第一块开始放，第二次从第二块开始放

### 2. 页式存储、段式存储、段页式存储

#### 2.1 页式存储

* **页式有分物理地址和逻辑地址**

  逻辑地址如下，逻辑地址通过页号到页表里面查找物理地址的快号，然后找到物理地址，页内地址和物理地址式一样的

![1551796990697](/assets/images/RuanKao_note/1551796990697.png)

![1551796966017](/assets/images/RuanKao_note/1551796966017.png)

![1551797261385](/assets/images/RuanKao_note/1551797261385.png)

* **页式存储的练习题**

![1551797289945](/assets/images/RuanKao_note/1551797289945.png)

#### 2.2 段式存储

* 段式存储是按逻辑方式划分的，比如A程序分再一个段里面，便于共享内存

![1551797876707](/assets/images/RuanKao_note/1551797876707.png)

* 段式存储的段表式有段号，段长，和开始的基址

  ![1551798061020](/assets/images/RuanKao_note/1551798061020.png)

  ![1551798184287](/assets/images/RuanKao_note/1551798184287.png)

#### 2.3 段页式存储

![1551798171433](/assets/images/RuanKao_note/1551798171433.png)

#### 2.4 块表

按内容存取，慢表是放在内存中的

![1551798278324](/assets/images/RuanKao_note/1551798278324.png)

### 3. 页面置换算法

* 最优算法：理论层面上的算法，已知访问的页面顺序，然后再来计算淘汰，比较理论

* 随机算法：随机淘汰一个页面

* **先进先出(FIFO算法)**：看哪个页面是最先进入就最先淘汰

  * 会产生“抖动”，抖动是指我分配资源越多，但是反而效率最低

    ![1551799038155](/assets/images/RuanKao_note/1551799038155.png)

    

* **最近最少使用(LRU算法)**:

  比如501203，如果内存空间只有3页，那么前面三次会缺页，导入501，第四次缺页，此时，501都被访问到，那么先淘汰最远访问的5，导入2，接下来导入0，没有缺页，最后一次导入3，如果按照先进先出算法，那么要淘汰0号页，但是因为采用的是LRU算法，按时间顺序，0刚刚被访问到了，其次是2，再其次是1，则淘汰掉1，导入3

  ![1551832641814](/assets/images/RuanKao_note/1551832641814.png)

* **题目**

  ![1551833831538](/assets/images/RuanKao_note/1551833831538.png)

## 2.04 文件管理

### 1. 索引文件结构

![1551835009476](/assets/images/RuanKao_note/1551835009476.png)

![1551835522161](/assets/images/RuanKao_note/1551835522161.png)

### 2. 文件和树型目录结构

* **树型目录结构**

  ![1551835676840](/assets/images/RuanKao_note/1551835676840.png)

  

* 文件

  ![1551835711025](/assets/images/RuanKao_note/1551835711025.png)

### 3. 空闲存储空间的管理

在磁盘上会有大量的空闲空间，要把他们管理起来，以便有新文件的时候，可以分配空间给它

![1551835838722](/assets/images/RuanKao_note/1551835838722.png)

* 空闲区表法

  把空闲空间存在一个表里

* 空闲链表法

  把空闲空间存取一个链表，像2.03-2.1分区存储组织那样子

* 成组链接法

  是分组也分链

* 位示图法

  ![1551836140467](/assets/images/RuanKao_note/1551836140467.png)

  1表达的区域表示已经被占用，0表示未占用，像电影院的座位就像是位示图法

  * 例题

    ![1551836789723](/assets/images/RuanKao_note/1551836789723.png)

    这里需要注意物理块是从0号开始的，位置是从0号开始的，字是从1开始算

## 2.05 设备管理

### 1. 数据传输控制方式

> 指的是内存和外设之间的传输控制问题，解决这个问题的方法有以下

![1551837282188](/assets/images/RuanKao_note/1551837282188.png)

* 程序控制方式

  大部分为CPU的控制，外设没有反馈的方式，就像别人做一个工作，你老是问它做好了没有

* 程序终端方式

  外设完成了任务，就发一个中断

* DMA方式(直接存取控制方式)

  有个DMA控制器，外设和内存直接就由这个控制器掌握，CPU完成初始化操作，DMA控制器完成后就交由CPU完成接下来的操作

### 2. 虚设备与SPOOLING(多任务缓冲)技术

![1551837718714](/assets/images/RuanKao_note/1551837718714.png)

使用缓冲区，如果多人打印，都可以打，不会显示设备被占用，但是是存在打印队列里面

![1551837966087](/assets/images/RuanKao_note/1551837966087.png)

### 3. 微内核操作系统

> `微内核操作系统`就是把内核缩小一点，就是把核心权力缩小，像皇帝的权力缩小，如果皇帝出事了，整个系统不出很大问题，如果其他分出去的权力机构出事了，就换掉(重启)一个就行，以前的XP经常蓝屏就是因为用了`单体内核`而没有使用微内核

![1551838205816](/assets/images/RuanKao_note/1551838205816.png)

分出去的是用户态，核心是核心态

![1551838359179](/assets/images/RuanKao_note/1551838359179.png)